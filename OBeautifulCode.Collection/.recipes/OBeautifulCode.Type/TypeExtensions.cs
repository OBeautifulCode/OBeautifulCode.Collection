// --------------------------------------------------------------------------------------------------------------------
// <copyright file="TypeExtensions.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Type.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Type.Recipes
{
    using System;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;

    using static System.FormattableString;

    /// <summary>
    /// Extension methods on type <see cref="Type"/>.
    /// </summary>
#if !OBeautifulCodeTypeRecipesProject
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Type.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static class TypeExtensions
    {
        private static readonly Type[] CollectionTypes =
        {
            typeof(Collection<>),
            typeof(ICollection<>),
            typeof(ReadOnlyCollection<>),
            typeof(IReadOnlyCollection<>),
            typeof(List<>),
            typeof(IList<>),
            typeof(IReadOnlyList<>)
        };

        private static readonly Type[] OrderedCollectionTypes =
        {
            typeof(Collection<>),
            typeof(ReadOnlyCollection<>),
            typeof(List<>),
            typeof(IList<>),
            typeof(IReadOnlyList<>)
        };

        private static readonly Type[] DictionaryTypes =
        {
            typeof(Dictionary<,>),
            typeof(IDictionary<,>),
            typeof(ReadOnlyDictionary<,>),
            typeof(IReadOnlyDictionary<,>),
            typeof(ConcurrentDictionary<,>),
        };

        private static readonly Regex GenericBracketsRegex = new Regex("<.*>", RegexOptions.Compiled);

        private static readonly CodeDomProvider CodeDomProvider = CodeDomProvider.CreateProvider("CSharp");

        private static readonly Dictionary<Type, string> Aliases = new Dictionary<Type, string>
        {
            { typeof(byte), "byte" },
            { typeof(sbyte), "sbyte" },
            { typeof(short), "short" },
            { typeof(ushort), "ushort" },
            { typeof(int), "int" },
            { typeof(uint), "uint" },
            { typeof(long), "long" },
            { typeof(ulong), "ulong" },
            { typeof(float), "float" },
            { typeof(double), "double" },
            { typeof(decimal), "decimal" },
            { typeof(object), "object" },
            { typeof(bool), "bool" },
            { typeof(char), "char" },
            { typeof(string), "string" },
            { typeof(void), "void" },
        };

        /// <summary>
        /// Determines if a type is an anonymous type.
        /// </summary>
        /// <param name="type">Type to check.</param>
        /// <returns>A value indicating whether or not the type provided is anonymous.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsAnonymous(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = Attribute.IsDefined(type, typeof(CompilerGeneratedAttribute), false)
                             && type.Namespace == null
                             && type.IsGenericType 
                             && type.Name.Contains("AnonymousType")
                             && (type.Name.StartsWith("<>", StringComparison.Ordinal) || type.Name.StartsWith("VB$", StringComparison.Ordinal))
                             && type.Attributes.HasFlag(TypeAttributes.NotPublic);

            return result;
        }

        /// <summary>
        /// Determines if a type is an anonymous type using a faster, but potentially
        /// less accurate heuristic than <see cref="IsAnonymous(Type)"/>.
        /// </summary>
        /// <param name="type">Type to check.</param>
        /// <returns>A value indicating whether or not the type provided is anonymous.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsAnonymousFastCheck(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = type.Namespace == null;

            return result;
        }

        /// <summary>
        /// Determines if a type if assignable to another type.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/questions/74616/how-to-detect-if-type-is-another-generic-type/1075059#1075059" />.
        /// </remarks>
        /// <param name="type">The current type.</param>
        /// <param name="otherType">The type to check for ability to assign to.</param>
        /// <param name="treatUnboundGenericAsAssignableTo">Treats an unbound generic as a type that can be assigned to (e.g. IsAssignableTo(List&lt;int&gt;, List&lt;&gt;)).</param>
        /// <returns>
        /// true if <paramref name="type"/> can be assigned to <paramref name="otherType"/>; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="otherType"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="type"/>.<see cref="Type.IsGenericTypeDefinition"/> is true.</exception>
        public static bool IsAssignableTo(
            this Type type,
            Type otherType,
            bool treatUnboundGenericAsAssignableTo = false)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (otherType == null)
            {
                throw new ArgumentNullException(nameof(otherType));
            }

            if (type.IsGenericTypeDefinition)
            {
                throw new ArgumentException(Invariant($"{nameof(type)}.{nameof(Type.IsGenericTypeDefinition)} is {true}"));
            }

            // type is equal to the other type
            if (type == otherType)
            {
                return true;
            }

            // type is assignable to the other type
            if (otherType.IsAssignableFrom(type))
            {
                return true;
            }

            // type is generic and other type is an unbounded generic type
            if (treatUnboundGenericAsAssignableTo && otherType.IsGenericTypeDefinition)
            {
                // type's unbounded generic version is the other type
                if (type.IsGenericType && type.GetGenericTypeDefinition() == otherType)
                {
                    return true;
                }

                // type implements an interface who's unbounded generic version is the other type
                if (type.GetInterfaces().Any(_ => _.IsGenericType && (_.GetGenericTypeDefinition() == otherType)))
                {
                    return true;
                }

                var baseType = type.BaseType;
                if (baseType == null)
                {
                    return false;
                }

                // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                var result = baseType.IsAssignableTo(otherType, treatUnboundGenericAsAssignableTo);
                return result;
            }

            return false;
        }

        /// <summary>
        /// Determines if the specified type is a class type, that's not anonymous, and is closed.
        /// </summary>
        /// <remarks>
        /// This is basically asking, "Is this a class type that can be constructed/new-ed up?"
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a class type, non-anonymous, and closed.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsNonAnonymousClosedClassType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result =
                type.IsClass &&
                (!type.IsAnonymous()) &&
                (!type.IsGenericTypeDefinition); // can't do an IsAssignableTo check on generic type definitions

            return result;
        }

        /// <summary>
        /// Determines if the specified type is <see cref="Nullable{T}"/>.
        /// </summary>
        /// <remarks>Adapted from: <a href="https://stackoverflow.com/a/41281601/356790" />.</remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is <see cref="Nullable{T}"/>, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsNullableType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = Nullable.GetUnderlyingType(type) != null;

            return result;
        }

        /// <summary>
        /// Determines if the specified type is one of the following <see cref="System"/> collection types: <see cref="CollectionTypes"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a <see cref="System"/> collection type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemCollectionType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericType = type.GetGenericTypeDefinition();

            var result = CollectionTypes.Any(_ => genericType == _);
            return result;
        }

        /// <summary>
        /// Determines if the specified type is one of the following <see cref="System"/> dictionary types: <see cref="DictionaryTypes"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a <see cref="System"/> dictionary type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemDictionaryType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericType = type.GetGenericTypeDefinition();

            var result = DictionaryTypes.Any(_ => genericType == _);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is a <see cref="System"/> ordered <see cref="IEnumerable{T}"/>:
        /// Either an <see cref="Array"/> or one of these types: <see cref="OrderedCollectionTypes"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a <see cref="System"/> ordered <see cref="IEnumerable{T}"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemOrderedCollectionType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.IsArray)
            {
                return true;
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericType = type.GetGenericTypeDefinition();

            var result = OrderedCollectionTypes.Any(_ => genericType == _);

            return result;
        }

        /// <summary>
        /// Gets a compilable, readability-optimized string representation of the specified type.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
        /// Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
        /// Helpful breakdown of generics: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <param name="throwIfNoCompilableStringExists">Optional value indicating whether to throw a <see cref="NotSupportedException"/> if there's no compilable representation of the specified type.</param>
        /// <returns>
        /// A compilable, readability-optimized string representation of the specified type
        /// OR
        /// null if there is no compilable representation and <paramref name="throwIfNoCompilableStringExists"/> is true.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic open constructed type, which is not supported.</exception>
        /// <exception cref="NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic parameter.</exception>
        public static string ToStringCompilable(
            this Type type,
            bool throwIfNoCompilableStringExists = false)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            string result;

            if (type.IsAnonymous())
            {
                if (throwIfNoCompilableStringExists)
                {
                    throw new NotSupportedException("Anonymous types are not supported.");
                }
                else
                {
                    result = null;
                }
            }
            else if (type.IsGenericParameter)
            {
                if (throwIfNoCompilableStringExists)
                {
                    // note that IsGenericParameter and ContainsGenericParameters will return true for generic parameters,
                    // hence we order the IsGenericParameter check first.
                    throw new NotSupportedException("Generic parameters not supported.");
                }
                else
                {
                    result = null;
                }
            }
            else
            {
                if (Aliases.ContainsKey(type))
                {
                    result = Aliases[type];
                }
                else if (type.IsNullableType())
                {
                    result = Nullable.GetUnderlyingType(type).ToStringCompilable() + "?";
                }
                else if (type.IsArray)
                {
                    result = type.GetElementType().ToStringCompilable() + "[]";
                }
                else
                {
                    result = CodeDomProvider.GetTypeOutput(new CodeTypeReference(type.FullName?.Replace(type.Namespace + ".", string.Empty)));

                    if (type.IsGenericType)
                    {
                        if (type.IsGenericTypeDefinition)
                        {
                            result = result.Replace(" ", string.Empty);
                        }
                        else if (type.ContainsGenericParameters)
                        {
                            if (throwIfNoCompilableStringExists)
                            {
                                throw new NotSupportedException("Generic open constructed types are not supported.");
                            }
                            else
                            {
                                result = null;
                            }
                        }
                        else
                        {
                            var genericParameters = type.GetGenericArguments().Select(_ => _.ToStringCompilable()).ToArray();

                            result = GenericBracketsRegex.Replace(result, "<" + string.Join(", ", genericParameters) + ">");
                        }
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Gets a readability-optimized string representation of the specified type.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
        /// Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
        /// Helpful breakdown of generics: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <param name="options">The options to use when generating the string representation.</param>
        /// <returns>
        /// A readability-optimized string representation of the specified type
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static string ToStringReadable(
            this Type type,
            ToStringReadableOptions options = ToStringReadableOptions.None)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var assemblyDetailsTypes = new List<Type>();

            var result = type.ToStringReadableInternal(options, assemblyDetailsTypes);

            var includeAssemblyDetails = options.HasFlag(ToStringReadableOptions.IncludeAssemblyDetails);

            if (includeAssemblyDetails && assemblyDetailsTypes.Any())
            {
                result = result + " || " + string.Join(" | ", assemblyDetailsTypes.Select(_ => _.ToAssemblyDetails()).ToArray());
            }

            return result;
        }

        private static string ToStringReadableInternal(
            this Type type,
            ToStringReadableOptions options,
            IList<Type> assemblyDetailsTypes = null)
        {
            string result;

            if (type.IsGenericParameter)
            {
                result = type.Name;
            }
            else if (Aliases.ContainsKey(type))
            {
                assemblyDetailsTypes?.Add(type);

                result = Aliases[type];
            }
            else if (type.IsNullableType())
            {
                result = Nullable.GetUnderlyingType(type).ToStringReadableInternal(options, assemblyDetailsTypes) + "?";
            }
            else if (type.IsArray)
            {
                result = type.GetElementType().ToStringReadableInternal(options, assemblyDetailsTypes) + "[]";
            }
            else
            {
                assemblyDetailsTypes?.Add(type);

                result = CodeDomProvider.GetTypeOutput(new CodeTypeReference(type.FullName?.Replace(type.Namespace + ".", string.Empty) ?? type.Name));

                var includeNamespace = options.HasFlag(ToStringReadableOptions.IncludeNamespace);
                if (includeNamespace && (type.Namespace != null))
                {
                    result = type.Namespace + "." + result;
                }

                if (type.IsGenericType)
                {
                    var isAnonymous = type.IsAnonymous();

                    if (isAnonymous)
                    {
                        result = result.Replace("<>f__", string.Empty);
                    }

                    string[] genericParameters;
                    if (isAnonymous && type.IsGenericTypeDefinition)
                    {
                        genericParameters = type.GetGenericArguments().Select((_, i) => "T" + (i + 1)).ToArray();
                    }
                    else
                    {
                        genericParameters = type.GetGenericArguments().Select(_ => _.ToStringReadableInternal(options, assemblyDetailsTypes)).ToArray();
                    }

                    result = GenericBracketsRegex.Replace(result, "<" + string.Join(", ", genericParameters) + ">");
                }
            }

            return result;
        }

        private static string ToAssemblyDetails(
            this Type type)
        {
            if (type.IsGenericType)
            {
                type = type.GetGenericTypeDefinition();
            }

            var fullyQualifiedTypeName = type.ToStringReadableInternal(ToStringReadableOptions.IncludeNamespace);

            var assemblyName = type.Assembly.GetName();

            var result = fullyQualifiedTypeName + " => " + assemblyName.Name + " (" + assemblyName.Version + ")";

            return result;
        }
    }
}
